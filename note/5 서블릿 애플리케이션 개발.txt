5. 서블릿 애플리케이션 개발

준비물: 메이븐, 톰캣

new Maven module
create from archetype: maven-archetype-webapp
package me.hjeong.servletapplication
bundle maven 3 설정

Maven Webapp Archetype
    maven-archetype-webapp is an archetype which generates a sample Maven webapp project:

    project
    |-- pom.xml
    `-- src
        `-- main
            `-- webapp
                |-- WEB-INF
                |   `-- web.xml
                `-- index.jsp

pom.xml 에 servlet dependency 추가
    mvnrepository.com/
    java servlet 4.0.1 검색

    <!-- https://mvnrepository.com/artifact/javax.servlet/javax.servlet-api -->
    <dependency>
        <groupId>javax.servlet</groupId>
        <artifactId>javax.servlet-api</artifactId>
        <version>4.0.1</version>
        <scope>provided</scope>
    </dependency>

    <scope>: 해당 의존성을 언제 클래스 패쓰에 넣고 쓸 것이냐

    ex) junit 의 scope이 test라면
        -> 이 뜻은 junit을 소스 클래스 패쓰에서는 쓰지 못한다는 뜻.
        -> 오로지 테스트를 실행할 때만 쓸 수 있다.

    ex) servlet은 provided scope 이다.
        -> 이 뜻은 코딩하는 시점에서는 쓸 수 있는데
        -> jar war 패키징 할 때는 빠진다.
        -> 대신 톰캣 컨테이너에서 제공해 줄 것이기 때문에
        -> 런타임 할 때에는 클래스패쓰에 servlet 의존성을 가지고 있지 않아도 된다는 뜻


java 디렉토리 추가 후, 소스로 지정하기
    src/main/java 디렉토리 추가

    File
    - Project Structure
    - Module
    - src/main/java: Mark as Source

    java 안에 me.hjeong 패키지 만듦
    me.hjeong.HelloServlet 클래스 생성


서블릿 구현
    public class HelloServlet extends HttpServlet {
        @Override
        public void init() {
            System.out.println("init");
        }

        Get 요청이 왔을 때 보여줄 html 만들어 주기
        @Override
        protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
            System.out.println("doGet");
            resp.getWriter().println("<html>");
            resp.getWriter().println("<head>");
            resp.getWriter().println("<body>");
            resp.getWriter().println("<h1>Hello Servlet</h1 >");
            resp.getWriter().println("</body>");
            resp.getWriter().println("</head>");
            resp.getWriter().println("</html>");
        }

        @Override
        public void destroy() {
            System.out.println("destroy");
        }
    }

    만든 서블릿을 독자적으로 우리가 실행하는 방법은 없다.
    따라서 톰캣 컨테이너에 배포하는 식으로 실행해보자.

    Add Configuration
    + Tomcat Server - Local

    Application server: Tomcat 9
    // 이 애플리케이션을 실행할 서버

    Fix war exploded 추가
    // 배포할 때 즉 톰캣에 어플리케이션을 띄울 때 해당 어플리케이션을 와르 패키지로 배포할 것인데
    // 와르로 묶어서 톰캣에 배포할수도 있고 압축을 풀어헤친 방식으로 배포할 수도 있다.
    // war-exploded: 와르긴 한데 exploded 는 풀어놓은 것을 배포하겠다.

    Application context: /_2_servletapplication_war_exploded
    애플리케이션 컨텍스트 -> 앱이 뜨는 위치
    http://localhost:8080/_2_servletapplication_war_exploded/
    앱이 띄워지면 처음으로 열어줄 url 에 애플리케이션 컨텍스트가 들어와있다.


실행!
    빌드를 한 뒤
    데모 exploded 라는 아키텍트가 배포를 기다리고 있고
    톰캣이 뜨면
    Artifact is being ... 라며 배포됨을 로그에 찍힌다.
    설정에 따라서 url 을 띄워준다

    허나 아직 이 서블릿 애플리케이션을 쓸 수 없다.
    서블릿을 등록시켜주자!


서블릿 등록
    web.xml 에 servlet, servlet-mapping 을 정의해줘야 한다.
    한 서블릿에 대해서 <servlet>, <servlet-mapping> 한 세트가 있어야 한다.

    <web-app>
      <display-name>Archetype Created Web Application</display-name>
      <servlet>
        <servlet-name>hello</servlet-name>
        <servlet-class>me.hjeong._2.HelloServlet</servlet-class>
      </servlet>
      <servlet-mapping>
        <servlet-name>hello</servlet-name>
        <url-pattern>/hello</url-pattern>
      </servlet-mapping>
    </web-app>

    web.xml 을 수정하고 다시 Run!
    ApplicationContext 의 이름을 - 로 지정하면 url 경로가 짧아진다.


원리

    요청이 들어오면 서블릿 컨테이너가 요청을 받는다.
    web.xml 을 토대로 해당 요청을 처리할 서블릿 클래스를 찾고
    해당 서블릿이 최초로 사용되는 경우라면 서블릿 인스턴스를 만들어 메모리에 올린다.

    서블릿 라이프 사이클에 따라서 init() 호출 후
    Get 요청이 들어왔으므로 이를 처리하기 위해 doGet() 이 호출되고
    브라우저에 html 이 보이는 것을 확인할 수 있다.

    새로고침해서 요청을 다시 하는 경우에 doGet() 만 호출됨
    서블릿이 인스턴스화되어 메모리에 올라와있기 때문에 init() 은 더 이상 호출되지 않는다.

    서블릿 컨테이너를 종료하면 destroy() 가 호출되는 것을 볼 수 있다.
    메모리에 올린 서블릿들을 내리는 과정이다.

