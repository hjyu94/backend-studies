20. 스프링 AOP: @AOP

애노테이션 기반의 스프링 @AOP

의존성 추가
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-aop</artifactId>
    </dependency>

애스팩트 정의
    ● @Aspect
    ● 빈으로 등록해야 하니까 (컴포넌트 스캔을 사용한다면) @Component도 추가.

포인트컷 정의
    ● @Pointcut(표현식)
    ● 주요 표현식: execution, @annotation, bean
    ● 포인트컷 조합: &&, ||, !

어드바이스 정의
    ● @Before
    ● @AfterReturning
    ● @AfterThrowing
    ● @Around

참고
    ● https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#aoppointcuts

-----------------------------------------------------------------------


애노테이션 기반의 스프링 @AOP

프록시 클래스를 삭제하면 더 이상 시간 측정이 안됨(ch19)
스프링 AOP를 사용하기 위해 의존성을 추가한다.

의존성 추가
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-aop</artifactId>
    </dependency>

애스팩트 정의
    ● @Aspect
    ● 빈으로 등록해야 하니까 (컴포넌트 스캔을 사용한다면) @Component도 추가.

포인트컷 정의
    ● @Pointcut(표현식)
    ● 주요 표현식
        ○ execution
        ○ @annotation
        ○ bean
    ● 포인트컷 조합 ○ &&, ||, !

ex)
    새 클래스 PerfAspect 추가

    애노테이션 기반 스프링 IoC 쓰고 있기 때문에 컴포넌트 스캔으로 빈을 등록할거고
    컴포넌트 애노테이션을 붙여서 빈으로 등록했다.

AOP를 적용하면?

        class A, B, C 에서 컨션들을 제거하고

        AspectX     AspectY     AspectZ
         @@@@@       #####       $$$$$      -> Advise
        --------    --------    --------
         A,B,C       A,B         A,C        -> Taraget

    컨션별로 하나의 Aspect를 만들어 컨션에서 했던 코드와, 이 코드가 적용될 부분을 하나로 모듈화함.

    실제 하던일을 독립적으로 정의하고(->Advise)
    이 일을 어디에 적용해야 하는지(->Pointcut)를 입력한다.
    이 기능(Advise)을 어디 어디 어디에 해야 한다고 알려주는 것

    해야 할일과 어디에 적용할것인가
    Advise와 Pointcut을 정의해야 한다.

    @Component
    @Aspect
    public class PerfAspect {
        public Object logPerf(ProceedingJoinPoint pip) throws Throwable {
            Object retVal = pip.proceed();
            return retVal;
        }
    }
    joinPoint 시점에 Aspect의 advise가 적용이 될 것
    publishEvent, createEvent 메소드 -> 얘네가 pip (target)
    타겟에 해당하는 메소드(pip)를 호출하고 결과값을 리턴하는 코드이다.

    이제 앞뒤로 시간을 재서 출력하는 Advise를 추가해보자

    @Component
    @Aspect
    public class PerfAspect {
        public Object logPerf(ProceedingJoningPoint pip) throws Throwable {
            long begin = System.currentTimeMillis(); // ***
            Object retVal = pip.proceed();
            System.out.println(System.currentTimeMillis() - begin); // ***
            return retVal;
        }
    }
    이렇게 Advise (// *** 부분) 를 정의했으니 Pointcut을 정의해야 한다.

    @Component
    @Aspect
    public class PerfAspect {
        @Around("execution(* me.hjeong..*.EventService.*(..))")
        // 어라운드를 이용해서 어드바이스를 어떻게 적용할 것인가 정의할 수 있다.
        // me.hjeong 으로 시작하는 모든 패키지에서 EventService 클래스의 모든 메소드에 다음 메소드를 적용하라는 정보
        public Object logPerf(ProceedingJoningPoint pip) throws Trowable {
            long begin = System.currentTimeMillis();
            Object retVal = pip.proceed();
            System.out.println(System.currentTimeMillis() - begin);
            return retVal;
        }
    }

    문제!
    deleteEvent 에는 적용하고 싶지 않았다.

    이 경우는 execution 보다 annotation을 적용하면 좀 더 편하다.
    Aspect의 Pointcut을 annotation을 사용해서 정의한다

        @Component
        @Aspect
        public class PerfAspect {
            @Around("@annotation(PerLogging)")
            // PerLogging Annotation이 붙은 곳에서만 적용해라
            public Object logPerf(ProceedingJoningPoint pip) throws Trowable {
                long begin = System.currentTimeMillis();
                Object retVal = pip.proceed();
                System.out.println(System.currentTimeMillis() - begin);
                return retVal;
            }
        }

    new interface: PerLogging

        @Documented // 자바 doc 만들 때 다큐멘테이션이 될 수 있도록
        @Target(ElementType.METHOD)
        @Retention(RetentionPolicy.CLASS)
        public @interface PerLoggin{
        }

        @Retention 정보가 CLASS 이상이어야 한다(CLASS, RUNTIME 이어야 하고 SOURCE 면 안된다)
            : 이 어노테이션 정보를 얼마나 유지할 것인가.
            : 클래스 파일까지 해당 어노테이션을 유지하겠다는 뜻
            (해당 어노테이션을 붙인 메소드 자바 파일을 컴파일하여 나오는 .class 파일까지 해당 어노테이션을 유지를 하겠다.)
            : @Retention 을 사용하지 않았을 때 기본값은 CLASS임
            : @Retention(RetentionPolicy.SOURCE)로 변경하면 컴파일한 뒤에는 어노테이션 정보가 사라진다.



    이제 필요한 부분에 가서 @PerLogging 만 붙이면 편해진다.
    만든 PerLogging 어노테이션을 성능 테스트가 필요한 메소드에 붙인다.

        // Real Subject
        @Service
        public class SimpleEventService implements EventService {
            @PerLogging
            @Override
            void createEvent() {
                Thread.sleep(1000);
                System.out.println("Created an event");
            }
            @PerLogging
            @Override
            void publishEvent() {
                Thread.sleep(2000);
                System.out.println("Published an event");
            }
            @Override
            void deleteEvent() {
                System.out.println("Delete an event");
            }
        }

    실행! deleteEvent() 는 시간을 측정하지 않음을 볼 수 있다.

    어라운드같이 강력한 어드바이스가 필요하진 않는 경우 사용 가능
    @Before("bean(SimpleEventService)")
    public Object logPerf(ProceedingJoinPoint pip) throws Throwable {
        ...
    }
    simpleEventService의 모든 메소드 실행 이전에 실행된다.

참고
    ● https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#aoppointcuts