26. HTTP 메시지 컨버터 2부: JSON


JacksonJSON 2 을 사용해서 요청과 응답에 객체를 json 문자열로 변환해보자.


스프링 부트를 사용하지 않는 경우
    ● 사용하고 싶은 JSON 라이브러리를 의존성으로 추가
    ● GSON
    ● JacksonJSON
    ● JacksonJSON 2


스프링 부트를 사용하는 경우
    ● 기본적으로 JacksonJSON 2가 의존성에 들어있다.
    ● 즉, JSON용 HTTP 메시지 컨버터가 기본으로 등록되어 있다.

    JSON용 HTTP 메세지 컨버터는 의존성에 따라서 조건적으로 등록된다

    WebMvcConfigurationSupport 에 그렇게 정의되어 있다.
    addDefaultHttpMessageConverters() 에서 if 분기처리로 메세지 컨버터를 추가하고 있다.

    class WebMvcConfigurationSupport {
        private static final boolean romePresent;
        private static final boolean jaxb2Present;

        ... void addDefaultHttpMessageConverters(...) {
            if (romePresent) {
                messageConverters.add(new AtomFeedHttpMessageConverter());
                messageConverters.add(new RssChannelHttpMessageConverter());
            }
            // romePresent이 있으면 메세지 컨버터를 등록해라!

            if (jackson2XmlPresent) {
                ...
            }
            ...
        }
    }

    romePresent = ClassUtils.isPresent("com.rometools.rome.feed.WireFeed", classLoader);
    // romePresent 등등이 있냐 없냐는 풀 패키지 경로에 해당하는 클래스가 클래스패쓰에 있냐 없냐로 결정됨

    클래스패쓰에 해당하는 라이브러리가 들어가 있는 경우에만 해당 메세지 컨버터가 등록되는 것.
    기본적으로 spring-boot-starter-web안에 starter-json이 추가되고 그 안에 jackson을 갖고 있다.

    따라서 jackson2jason 을 갖고 있는 것.
    (jackson2Present = ClassUtils.isPresent("com.fasterxml.jackson.databind.ObjectMapper", classLoader) && ClassUtils.isPresent("com.fasterxml.jackson.core.JsonGenerator", classLoader);)


실습)
    @RestController
    public class SampleController {

        @GetMapping("/jsonMessage")
        public person jsonMessage(@RequestBody Person person)
            return person;
        }
    }
    // jackson2 가 제공하는 하는 ObjectWrapper를 사용해서
    // 요청 본문에 들어있는 json 문자열을 Person으로 받고
    // 내보내는 person 객체도 json 문자열로 내보내려고 한다

    @Autowired
    ObjectMapper objectMapper; // 스프링 부트 덕분에 이미 빈으로 등록되어 있다.

    @Test
    public void jsonMessage() throws Exception {
        Person person = new Person();
        person.setId(2019l);
        person.setName("hjeong");

        String jsonString = objectMapper.writeValueAsString(person);

        this.mockMvc.perform(get("/jsonMessage")

                    .contentType(MediaType.APPLICATION_JSON_UTF8)
                    .accept(MediaType.APPLICATION_JSON_UTF8)
                    // 여러가지 컨버터 중에서 어떤 컨버터를 사용하는지 판단은 컨텐츠 타입과 요청 헤더 정보를 참고한다.
                    // (1) contentType? 내가 본문에 보내는 데이터가 어떤 타입인지 서버에 알려주는 것
                    // (2) accept? 이 요청에 대한 응답으로 어떤 데이터를 원하는지를 서버에 알려주는 것

                    .content(jsonString)) // json 문자열을 본문에 주자

                .andDo(print())
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.id").value(2019))
                .andExpect(jsonPath("$.name").value("hjeong"))
        ;
    }

    테스트 실행! 성공!
    뷰를 만들어서 테스트하기 어려운 경우 Postman 을 사용해서 보여줄 수 있다.


참고
    ● JSON path 문법
    ● https://github.com/json-path/JsonPath
    ● http://jsonpath.com/







