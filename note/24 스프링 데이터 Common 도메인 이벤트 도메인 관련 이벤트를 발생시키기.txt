24. 스프링 데이터 Common: 도메인 이벤트 도메인 관련 이벤트를 발생시키기

Domain event publishing 기능!

스프링 프레임워크의 이벤트 관련 기능
    ● https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html#cont ext-functionality-events
    ● ApplicationContext extends​ApplicationEventPublisher
    ● 이벤트: extends ApplicationEvent
    ● 리스너
        ○ implements ApplicationListener<E extends ApplicationEvent>
        ○ @EventListener
 
스프링 데이터의 도메인 이벤트 Publisher
    ● @DomainEvents
    ● @AfterDomainEventPublication
    ● extends AbstractAggregateRoot<E>
    ● 현재는 save() 할 때만 발생 합니다.

------------------------------------------------------------------------------------------------------------

도메인의 변화(엔티티의 변화)를 이벤트로 발생시키고
리스너가 이 변화를 감지하고 일을 처리하면
어떠한 이벤트 기반의 프로그래밍을 할 수 있다.

도메인 이벤트를 만들고, 퍼블리싱하고, 리스닝 할 수 있다.
-> 스프링에서 제공하는 기능임
-> ApplicationContext가 EventPublisher의 기능도 한다!

[실습]
    Post라는 글이 draft 상태로 저장되고 사용자가 발행이라는 버튼을 눌러야만 publish가 된다.
    publish가 이뤄질 때 이벤트를 발생시키면 이를 처리하는 리스너가 있다고 가정해보자.

* 이벤트 정의하기

    public class PostPublishedEvent extends ApplicationEvent {
        private final Post post;

        public PostPublishedEvent(Object source) {
            super(source);
            this.post = (Post) source;
        }

        // getter
    }

* 이벤트가 publish 될 때 이벤트를 발생시키는 테스트

    public class PostRepositoryTest {
        @Autowired
        ApplicationContext applicationContext;

        @Test
        public void event() {
            Post post = new Post();
            post.setTitle("event");
            PostPublishedEvent event = new ...(post);

            applicationContext.publishEvent(event); // 던짐
        }
    }

* 이벤트가 발생되었을 때 처리할 리스너 핸들러

    public class PostListener implements ApplicationListener<PostPublishedEvent> {
        public void onApplicationEvent(PostPublishedEvent event){ // 이벤트가 발생했을 때 해야할 일
            System.out.println(event.getPost().getTitle() + " is published()");
        }
    }

* 리스너는 처음에는 빈이 아니라서 빈으로 등록해줘야 한다.

    테스트에서 Configuration 정의

    @Configuration
    public class PostRepositoryTestConfig {
        @Bean
        public PostListener postListener() {
            return new PostListener();
        }
    }

    @Import(PostRepositoryTestConfig.class) // 테스트를 할 때 리스너를 빈으로 등록한다.
    public class PostRepositoryTest {
        public void event() {...}
    }

    event 테스트 실행!
    (여기까지는 스프링 얘기!)


# 스프링 데이터의 도메인 이벤트 Publisher

    스프링 데이터가 엔티티가 save 될때 자동 이벤트 퍼블리싱 기능을 제공한다.
    어떤 엔티티에 쌓여있던 이벤트를 save() 하는 순간 모두 보내준다.

    ● @DomainEvents
        @DomainEvents 라는 곳에서 이벤트를 쌓아서 가지고 있고
    ● @AfterDomainEventPublication
        다 보낸 다음에 그 동안 쌓여있던 이벤트를(컬렉션에 있겠지???) 비워줘야 한다.
        @AfterDomainEventPublication 에서 자동으로 비워줌.

    이 두 어노테이션이 붙은 메소드들을 만들면 되는데
    우리가 직접 구현할 필요 없이 이미 만들어져있는 Aggregate 를 사용하자

    public class Post extends AbstractAggregateRoot<Post> { ... }

    스프링 데이터가 제공해주는 기능
    AbstractAggregateRoot 안을 보면 @DomainEvents, @AfterDomainEventPublication 이 구현되어 있다.

    ------------------------------------------------------------------------------------
    public class AbstractAggregateRoot<A extends AbstractAggregateRoot<A>> {

        private final transient List<Object> domainEvents = new ArrayList();

        @AfterDomainEventPublication
        protected void clearDomainEvents() {
            this.domainEvents.clear();
        }

        @DomainEvents
        protected Collection<Object> domainEvents() {
            return Collections.unmodifiableList(this.domainEvents);
        }

    }
    ------------------------------------------------------------------------------------

    우리가 직접 이벤트를 만들고, 던질 필요가 없어짐.

    @Test
    public void event() {
        postRepository.save(post.publish());
    }

    public Post publish() {
        this.registerEvent(new PostPublishedEvent(this);
        return this;
    }

    이렇게 하면 save() 할 때 Post의 domainEvents 안에 있던 이벤트들이 발생된다.


* 테스트

    @Test
    public void event() {
        Post post = new Post();
        post.setTitle("event");
        postRepository.save(post.publish());
    }

    implements ApplicationListener<PostPublishedEvent>가 안외워지면
    메소드에 @EventListener 만 붙여도 된다.
    단 해당 클래스가 빈으로 등록되어 있어야 한다.

    public class PostListener implements ApplicationListener<PostPublishedEvent> {
        public void onApplicationEvent(PostPublishedEvent event){ // 이벤트가 발생했을 때 해야할 일
            System.out.println(event.getPost().getTitle() + " is published()");
        }
    }

    ==

    public class PostListener {
        @EventListener
        public void onApplicationEvent(PostPublishedEvent event){ // 이벤트가 발생했을 때 해야할 일
            System.out.println(event.getPost().getTitle() + " is published()");
        }
    }

    @DataJpaTest 는 JPA 관련 데이터만 빈으로 등록되기 때문에 (슬라이싱 테스트)라서
    PostListener에 @Componenet 붙인다고 해서 빈으로 등록하지 않음.
    빈 설정을 테스트에서 @Import 해서 사용했던 것.


* 리스너 클래스 자체를 만들기 싫으면

    @Configuration
    public class PostRepositoryTestConfig {
        @Bean
        public ApplicationListener<PostPublishedEvent> postListener() {
            return new ApplicationListener<PostPublishedEvent>() {
                @Override
                public void onApplicationEvent(PostPublishedEvent event){
                    // ...
                }
            };
        }
    }

    설정 파일 안에 구현해도 된다.


