31. HTTP 요청 맵핑하기 1부: 요청 메소드


HTTP Method
    ● GET, POST, PUT, PATCH, DELETE, ...


GET 요청
    ● 클라이언트가 서버의 리소스를 요청할 때 사용한다.
    ● 캐싱 할 수 있다. (조건적인 GET으로 바뀔 수 있다.)
    // 응답을 보낼 때 캐싱에 관련한 데이터를 보낼 수 있다.
    // 조건적인 GET? IsNotModifed, isNotSince 등등
    // ex) 304 Not Modified라고 응답하면 본문을 보내지 않아도 응답이 수정되지 않은 경우에 한해
       클라쪽에서 캐싱한 데이터를 그대로 보여주기 때문에 요청 처리가 굉장히 빠르다.
    ● 브라우저 기록에 남는다.
    ● 북마크 할 수 있다.
    ● 민감한 데이터를 보낼 때 사용하지 말 것. (URL에 다 보이니까)
    ● idempotent
    // 같은 GET 요청을 하면 같은 응답이 돌아와야 한다.


POST 요청
    ● 클라이언트가 서버의 리소스를 수정하거나 새로 만들 때 사용한다.
    ● 서버에 보내는 데이터를 POST 요청 본문에 담는다.
    ● 캐시할 수 없다.
    ● 브라우저 기록에 남지 않는다.
    ● 북마크 할 수 없다.
    ● 데이터 길이 제한이 없다.
    // 같은 POST 요청이더라도 응답이 달라질 수 있다.


PUT 요청
    ● URI에 해당하는 데이터를 새로 만들거나 수정할 때 사용한다.
    ● POST와 다른 점은 “URI”에 대한 의미가 다르다.
        ○ POST의 URI는 보내는 데이터를 처리할 리소스를 지칭하며
        ○ PUT의 URI는 보내는 데이터에 해당하는 리소스를 지칭한다.
    ● Idempotent
    (POST는 Idenpotent 하지 않을 수 있다)


PATCH 요청
    ● PUT과 비슷하지만, 기존 엔티티와 새 데이터의 차이점만 보낸다는 차이가 있다.
    ● Idempotent
    리소스가 가진 일부 데이터만 수정하고 싶을 때는 PATCH,
    전체를 수정하고 싶을때는 POST, PUT 사용


DELETE 요청
    ● URI에 해당하는 리소스를 삭제할 때 사용한다.
    ● Idempotent


스프링 웹 MVC에서 HTTP method 맵핑하기
    ● @RequestMapping(method=RequestMethod.GET)
    ● @RequestMapping(method={RequestMethod.GET, RequestMethod.POST})
    ● @GetMapping, @PostMapping, ...


참고
    ● https://www.w3schools.com/tags/ref_httpmethods.asp
    ● https://tools.ietf.org/html/rfc2616#section-9.3
    ● https://tools.ietf.org/html/rfc2068


[실습]

    핸들러: 컨트롤러의 요청을 처리할 수 있는 메소드

    @Controller
    public class SampleController {
        @RequestMapping("/hello")
        // 특정 url을 매핑하는 경우, 기본적으로 모든 HTTP 메소드를 모두 허용한다
        @ResponseBody
        // return 하는 스트링을 본문에 실어준다
        public String hello() {
            return "hello";
        }
    }

    @RunWith(SpringRunner.class) // JUnit
    @WebMvcTest // 웹 쪽만 테스트 할 때 붙여줌, MockMvc 빈으로 주입 가능
    public class ControllerTest {
        @Autowired
        MockMvc mockMvc;

        @Test // JUnit이 테스트로 인식함
        public void helloTest() {
            mockMvc.perform(get("/hello")) // get, post, delete, put
                    .andDo(print()) // 로그 확인하기
                    .andExpect(status().isOk())
                    .andExpect(content().string("hello"))
            ;
        }
    }

    테스트 요청! -> 성공

    get 요청만 처리하고 싶다!

    @Controller
    public class SampleController {
        // @RequestMapping("/hello")
        @RequestMapping(value = "/hello", method = RequestMethod.GET)
        @ResponseBody
        public String hello() {
            return "hello";
        }
    }


    @Test
    public void helloTest() {
        mockMvc.perform(put("/hello"))
                .andDo(print()) // 로그 확인하기
                .andExpect(stratus().isMethodNotAllowed())
        ;
    }

    컨트롤러는 get 요청만 받아 처리하는데 테스트에서 put 요청을 보내보았다.
    이런 경우 응답으로 405가 날아온다. (이 HTTP 메소드를 허용하지 않는다는 뜻)
    Request method PUT not supported. 서버가 허용하지 않는 요청을 보냈다!

    4번대는 요청이 잘못된 것.
    5번대는 서버쪽에서 문제가 있는 것.

    배열로 줄 수도 있다.

    @Controller
    public class SampleController {
        @RequestMapping(value = "/hello", method = {RequestMethod.GET, RequestMethod.PUT})
        @ResponseBody
        public String hello() {
            return "hello";
        }
    }


    @RequestMapping(value = "/hello", method = RequestMethod.GET)
    @GetMapping("/hello")
    (이외에도 @PosstMapping, ... 이 있다)

    @RequestMapping 어노테이션은 클래스 레벨에서도 붙일 수 있다.
    이 경우 해당 클래스의 모든 메소드에 요청 타입을 설정을 붙여주는 것

    @Controller
    @RequestMapping(method = RequestMethod.GET)
    public class SampleController {
        @RequestMapping("/hello")
        @ResponseBody
        public String hello() {
            return "hello";
        }
    }


