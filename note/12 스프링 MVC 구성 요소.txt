12. 스프링 MVC 구성 요소

DispatcherServlet이 사용하는 인터페이스 소개


DispatcherSerlvet의 기본 전략
    ● DispatcherServlet.properties


(*)은 List로 여러개를 쓸 수 있는 경우

MultipartResolver
    ● 파일 업로드 요청 처리에 필요한 인터페이스
    ● HttpServletRequest를 MultipartHttpServletRequest로 변환해주어
    요청이 담고 있는 File을 꺼낼 수 있는 API 제공.

    MultipartResolver 타입의 빈이 등록되어 있어야 DispatcherServlet이 그 빈을 사용할 수 있고
    그 빈을 DispatcherServlet이 가지고 있어야 파일 업로드 요청을 처리할 수 있다.
    HTTP에서 컨텐츠 헤더가 Multipart인 요청

    MultipartResolver의 자세한 설명은 MultipartResolver.class 내
    public interface MultipartResolver 위의 주석 설명 참고할 것

    스프링에서는 기본값이 null, 스프링 부트에서는 기본적으로 하나 구현되어 있는게 등록되어 있음.


LocaleResolver
    ● 클라이언트의 위치(Locale) 정보를 파악하는 인터페이스
    ● 기본 전략은 요청의 accept-language를 보고 판단.

    요청이 DispatcherServlet에 들어왔을 때 요청을 분석하는 단계에서 사용됨.
    메세지 소스(스프링 핵심기술 강좌 참조)에서 적절한 언어에 해당하는 메세지로 메세지 키 값을 리졸빙해서 해당 언어로 보여줌.
    (사용자가 영어권인지, 한국인지 어디인지 보고 적절한 언어로 보여주자!)


ThemeResolver
    ● 애플리케이션에 설정된 테마를 파악하고 변경할 수 있는 인터페이스
    ● 참고:
    https://memorynotfound.com/spring-mvc-theme-switcher-example/

    웹 브라우져에서 버튼을 클릭했을 때 css나 script가 바뀌는 등의 기능
    (흰색 <-> 검은색)
    theme이라는 키값을 뷰에 전달하고 뷰가 키값에 해당하는 적절한 리소스를 얻어와서(주로 css) 화면에 테마를 변경해 줌.

    요청이 들어올 때 사용자가 원하는 theme이 무엇인가? 사용자가 theme 을 변경하는 기능이 필요
    -> 이 둘을 ThemeResolver 에서 구현


HandlerMapping(*)
    ● 요청을 처리할 핸들러를 찾는 인터페이스

    해당 메소드가 핸들러다! 이 메소드 정보를 가지고 있는 핸들러 객체를 리턴한다.
    RequestMappingHandlerMapping: 어노테이션 기반, 해당 메소드가 핸들러가 된다.
    BeanNameUrlHandlerMapping: bean 이름을 보고 해당 빈을 찾았으면 그 클래스가 핸들러가 됨


HandlerAdapter(*)
    ● HandlerMapping이 찾아낸 “핸들러”를 처리하는 인터페이스
    ● 스프링 MVC 확장력의 핵심
    (핸들러를 얼마든지 원하는 대로 커스텀 할 수 있다.)


HandlerExceptionResolver(*)
    ● 요청 처리 중에 발생한 에러 처리하는 인터페이스


RequestToViewNameTranslator
    ● 핸들러에서 뷰 이름을 명시적으로 리턴하지 않은 경우, 요청을 기반으로 뷰 이름을 판단하는 인터페이스
    @GetMapping("/sample")
    public Spring sample()
        return "/WEB-INF/sample.jsp";
    }

    >>
        @GetMapping("/sample")
        public void sample()
        }

    이처럼 뷰 이름을 리턴하는 경우에 뷰 이름을 생략해버릴 수도 있는데 그 경우에도 동작함
    sample 로 요청이 들어왔으니 뷰 이름도 sample 이겠지! 라고 처리해줌


ViewResolver(*)
    ● 뷰 이름(string)에 해당하는 뷰를 찾아내는 인터페이스
    (명시적으로 리턴해주던, RequestToViewNameTranslator가 찾아내주던 뷰 이름으로 뷰를 찾음)


FlashMapManager
    ● FlashMap 인스턴스를 가져오고 저장하는 인터페이스
    ● FlashMap은 주로 리다이렉션을 사용할 때 요청 매개변수를 사용하지 않고 데이터를 전달하고 정리할 때 사용한다.
    ● redirect:/events
        리다이렉션 후 GET 해서 데이터를 보여줘야 하니 url이 필요.
        redirect:/events/id/200
        redirect:/events?id=200
        리다이렉트할때 겟 요청하는 쪽으로 데이터를 보내야 하는데
        매개변수 사용하지 않고도 데이터를 전달해주는 기능
        FlashMapManager를 사용하면 매개변수 없이 redirect:/events 으로 보여줄 수 있게 됨

    [리다이렉션이 왜 필요한가]
    POST 요청 시 데이터를 받고 데이터 저장 후 그 뒤에 보통 리다이렉트를 하는데 그렇지 않으면
    화면에서 리프레쉬할때 POST 요청의 데이터가 또 넘어올 수 있음. -> 이 경우를 방지해야 함.

    POST 요청 후에는 GET 요청으로 리다이렉트해서 GET 요청으로 뷰를 보여주게 되면
    그 상황에서는 브라우져 리프레쉬를 해도 다시한번 form submission이 이뤄지는게 아니라 GET 요청이 들어오게 됨
    중복 form submission 을 방지하기 위한 요청 처리 패턴
