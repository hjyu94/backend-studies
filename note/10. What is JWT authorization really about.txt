What is JWT authorization really about

JWT stands for JSON web tokens is a very popular way to do user authorization in web apps today JWT has also become very popular in the context of micro-services and as a result of some of the other developments in the way we build web applications today in this tutorial we will learn more JWT is and how exactly it's used specifically in the context of securing web applications 

JWT is usually pronounced as shot by the way think of it as adding an extra a and there jaeil ability shot but I found it to be a little polarizing among the community so for the purposes of this tutorial I'm just calling and JWT 

okay alright so although JWT is commonly used for managing authorization the idea behind Jade ability is to create a standard way for two parties to communicate securely so there's this open industry standard specification called the RFC seven five one nine which outlines how a Jade ability should be structured and how to use it for exchanging information or claims as it's usually called. but since Jade ability is so widely used for authorization 

JWT
Focus on authorization

Authorization strategies
Session token
JSON web token

let's focus our attention in this tutorial to just that so when it comes to authorization in addition digit ability. there are a bunch more options including session tokens all these authorization mechanisms session token based authorization or GWT based authorization or any other mechanism. we'll think of in the future they all have one thing to blame.

HTTP
Stateless protocol

and that is HTTP you see HTTP is a stateless protocol what it means is that every interaction in HTTP needs to contain all the information needed for that interaction nothing is remembered from the four no state is maintained over like multiple requests. 


think about this. when you're accessing a page from a server what's the information you need to send it but if it's a simple static HTML page you don't need much you just need to send the URL of the page that you're looking for. And this ever since you back the page you need another page send another URL the server sends back that page so technically the server doesn't need to remember you have previous requests in this case each request is kind of self-contained so it's perfect for HTTP protocol so if the server application is static and available to everyone there's no problem okay



the problem is when the response from the server is dynamic and it depends on who the user is in this case the information you sent to the server is not just what page you want you obviously also need to tell the server who you are 


so when you have a server application as p1 and p2. that are accessible only by certain users you tell the server over HTTP am user A and I'd like page p1 the server goes ok your ass page p1. but then after that let's say you want one more page if you go hey thanks ever can also get p2 well that's actually not gonna work this server has no idea who you are this time because it doesn't remember what your previous request is in every interaction you have to provide all the details in all the information required for that interaction so you will again need to say hey server I'm user A and I'd like page p2 and now this ever knows what to do because all the information that the server needs to do the job is in that request no dependence on previous information.

A: 나는 유저 A 야 (with ID card)! 페이지 1 을 주렴
서버: ㅇㅋ 너는 유저 A라는게 확인이 되는구나 자 여기~
(잠시 후)
A: 안녕 나 페이지 2도 필요하던데 한장 줘!
서버: 응? 넌 누군데??
A: 잉?? 나 A였잖아!
서버: 나는 이전의 일을 하나도 기억 못하는 stateless HTTP로 통신해! 그러니 이번에도 신분증을 주렴!
A: @ㅆㅃ#ㄲㅃㄲ…...

 now you might say hang on that's not being my experience with the web apps for example you can log into a banking website with your user ID and password and the website says ok authenticated and when you go to the accounts page the website doesn't ask you wait who are you again doesn't do that the website knows who you are it remembers you until you log off right how does it do that what does that happen there are multiple ways in which web applications manage and remember sessions and to off the popular ways it's done is using something called tokens the two popular options are using session tokens and using JSON web tokens or JWT let's understand them both so that you really understand what GWT is all about let me give you an analogy let's say a customer has a support request with a customer care department try to support department he calls them up and he tells them what his issues are and the representative tries out some troubleshooting steps and when nothing works the representative says ok well let me transfer this to some other department and they can help please call back tomorrow this support representative makes a note of all the details including all the troubleshooting steps they've tried and they save it in the system and they give the customer a support ticket this ticket number is associated with all the details that the supporter has saved in the system so the next time the customer calls back the customer doesn't have to go through all the details again all the same steps again when he calls again what does he do he gives the same ticket number the new support representative or maybe the same support rep who doesn't remember the previous colonization they look up the ticket number and get all the details they've saved in the system this is kind of what's happening with authentication using session tokens when you authenticate the server creates a session and keeps track of it itself it creates a session ID to associate with that session and it gives that ID to you it's just like the support ticket in the example we just saw so subsequently the client passes this token to the server as a part of every request and the server looks it up and it identifies who the client is so the server typically has to serve multiple clients at the same time so having this client passed the session ID makes it makes it handy the server always knows who the client is and can look up the information based on this single token now how the client passes the session ID to the server really depends on the implementation but the most common approach is to save the session ID in a cookie so that it automatically gets added to the cookie header on every subsequent request ok authentication happens the server saves the state and returns a response for the cookie subsequent request from the browser automatically have the cookie in the header because that's what browsers do so the server has that information and can look it up again to identify the client this mechanism of saving session IDs as tokens saved in cookies has been working fine for quite a while now and again like I said this is probably the most popular mechanism for authorization for the most part there are a few problems with this approach though and that's where JWT comes in let's understand what those problems are the biggest problem is that this approach assumes something what does it assume it assumes that there's always just one monolithic server web application that used to be the case typically in the past but that's no longer the case these days modern web apps most modern web apps these days don't look like this they look like this you have multiple servers sharing the load that's it behind the load balancer when a request comes in the load balancer decides which server to the request to so here's the problem the seller could have their login request routed to server one and this session is in the memory of silver one the next request goes through the load balancer or in goes to server two now server two has no idea about this previous exchange since only server one can recognize and lookup that session ID token okay so well the solution is obvious you introduce a shared session cache that all these servers save sessions to and they look up session tokens from this is a typical use case for like a Redis cache sitting over here for this very reason the drawback of this is that there is one single point of failure now if this Redis instance goes down all the sessions are down which is right more some implementations don't do this what they do instead is they follow the sticky session pattern so basically the load balancer remembers which server has the given user session and it always redirects requests from that user to that specific server but yeah this isn't that scalable also imagine in the case of micro services where there are multiple servers working with each other how does section information get carried over between all these different micro service instances this is tricky okay now let's propose an alternative model you remember the customer service analogy that I told you let's say the service folks don't maintain state this time all right so let's say imagine there's no database there's no internet there's no phone let's say the customer has to walk up to the service department and the agent asks him what's wrong and he tells them the service guy says ok we'll work on it come back again tomorrow but imagine that you are the service rep and you don't want this customer to repeat his full story to some other rep when he comes in tomorrow right so what can you do to make this easy for the customer you don't have any store you don't have anything to save this interaction at your end and give him a case ID or a token all right so what do you do all right so here's an idea instead of registering the case in the system and giving the customer the case number which you cannot do in this case what you do is you write down all the details of the entry on a piece of paper and hand it to the customer and say okay bring this back with you the next time you're here and hand it to the customer rep that you talk to they can read this and understand and get all the details okay so this is a change from the previous model the customer rep isn't giving the customer or token ID that refers to the details the customer rep is giving the customer the details itself well if this were to happen does the customer have have to remember anything well though it's the customers responsibility to get that piece of paper for every subsequent interaction with that support department the support department doesn't have to remember anything which is good but this is drawback with this approach so let's say the customer brings in a piece of paper with a history of issues how does the support rep trust it there might be a malicious customer who takes a piece of paper and writes a complete history of bad customer service and goes to demand for a freebie as a result of being treated badly you know what I mean it's it's hard you need to make the record of history trustworthy well one solution is to sign the piece of paper that you give to the customer right if the support rep can securely sign the information state that's handed to the customer the next time the customer gets it the new support rep can verify the signature to ensure that it's valid this switched model is what's implied in the JWT mechanism imagine when the client authenticates instead of the server saving that user information in a state on the server and returning the ID as a token it returns the user information itself as a token right imagine a JSON payload being returned with the user information back every time the client makes a subsequent request the client sends the whole JSON token with the request saying this is who I am this is my ID and this is my name the server isn't saving anything every time a request comes in the server goes ok let's see who this is hmm this GWT says this user name is foo and they have successfully authenticated okay boys Letterman okay this token is not an ID here it's a JSON object which has all the information this my friends is what's called drumroll JSON web tokens JSON tokens exchange over the web JWT and of course the problem of security is handled here by signing the tokens that's handed across each time when a user authenticates the server just doesn't send any json object it sends something in a special signed format there's a signature here so when the client sends a subsequent request the sign the JWT is sent back to the server the server verifies the signature and it trust said only if it's valid in minutes valid all the information that the server needs is right there in the token this is really all that cheetah 3 tears it's a way for a client and a server to communicate and share information directly that has some meaning across multiple interactions without the server having to remember information for each client the fact that this happens to be between a client and a server and for authorization purposes is really incidental it could technically be used for anything like for example you can pretty much hand out party invitations in JWT format and then verify the GWT signature at the entrance of your party to make sure only the people you've invited have shown up don't do that though let's stick to authorization for GWT now so in the context of authorization if you were to contrast session IDs and trade abilities think of session ID tokens as a reference token right it's a reference to a state gwt's our value tokens it contains the value session ID tokens refer to a state on the server sheet abilities contain the value of itself notice that all along we've been talking about GWT as in what the token is and not how it's sent just like session IDs can be sent using cookies what GWT can be sent using cookies - you want to save that in local storage and the browser and send it you can do that - JWT our session tokens are just different options for what is exchanged how do you exchange them it's really up to you okay now what is the state of the tea looked like isn't it kind of painful to have to send a JSON object extra and every request that you make well it actually doesn't look like a JSON object errotica JWT it kind of looks something like this doesn't look like json does it there's actually a structure and a process of creating a JWT and in fact the reservation can take this token on your screen right now and figure out what the JSON payload is the heart is a solver they'll check out this next tutorial where I break down the structure of jade ability and I'll tell you how to parse a JWT as well as how to create new Jade abilities yourself we'll also be looking at some disadvantages of jade ability when compared to session IDs in the context of authorization check that out I'll see you there [Music] 
