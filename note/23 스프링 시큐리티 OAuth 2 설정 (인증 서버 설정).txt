23 스프링 시큐리티 OAuth 2 설정: 인증 서버 설정

의존성
    <dependency>
        <groupId>org.springframework.security</groupId>
        <artifactId>spring-security-test</artifactId>
        <version>${spring-security.version}</version>
        <scope>test</scope>
    </dependency>

토큰 발행 테스트
    ● User
    ● Client
    ● POST /oauth/token
        ○ HTTP Basic 인증 헤더 (클라이언트 아이디 + 클라이언트 시크릿)
        ○ 요청 매개변수 (MultiValuMap<String, String>)
            ■ grant_type: password
            ■ username
            ■ password
        ○ 응답에 access_token 나오는지 확인

Grant Type: Password
    ● Grant Type: 토큰 받아오는 방법
    ● 서비스 오너가 만든 클라이언트에서 사용하는 Grant Type
    ● https://developer.okta.com/blog/2018/06/29/what-is-the-oauth2-password-grant

AuthorizationServer 설정
    ● @EnableAuthorizationServer
    ● extends AuthorizationServerConfigurerAdapter

    ● configure(AuthorizationServerSecurityConfigurer security)
        ○ PassswordEncode 설정
    ● configure(ClientDetailsServiceConfigurer clients)
        ○ 클라이언트 설정
        ○ grantTypes
            ■ password  ■ refresh_token
        ○ scopes
        ○ secret / name
        ○ accessTokenValiditySeconds
        ○ refreshTokenValiditySeconds
    ● AuthorizationServerEndpointsConfigurer  
        ○ tokenStore
        ○ authenticationMaanger
        ○ userDetailsService


[실습]

AuthServerConfig.java 생성
    class AuthServerConfig { }


AuthServerConfigTest.java 생성
    - BaseControlelrTest 상속
    - @Autowired AccountService accountService;
    - 인증 토큰을 발급 받는 테스트


인증 서버가 설정이 되어 있다면 인증 토큰을 받을 수 있어야 한다.

(스프링 OAuth가 제공)
Grant Type 중  패스워드, 리프레쉬 토큰 두가지 방법을 쓸 것

Password라는 Grant Type으로 토큰을 받아와서 인증 받을 것
이 방식은 1 step 으로 인증을 받을 수 있다.

언제 패스워드를 그랜트타입으로 쓸 수 있느냐?
유저의 패스워드를 요구하기 때문에 third party에게 이런 방식을 허용해주면 안 됨
오로지 인증 정보를 가지고 있는 서비스가 만드는 앱에서만 사용할 수 있는 방식
이 정보를 보내면 액세스 토큰을 한번에 받아을 수 있는 장점이 있다.


AuthServerConfigTest
    @Test
    @TestDescription("인증 토큰을 발급 받는 테스트")
    public void getAuthToken() throws Exception {
        String username = "hjeong@email.com";
        String password = "hjeong";
        String clientId = "myApp";
        String clientSecret = "pass";

        this.mockMvc.perform(post("/oauth/token")
                    .with(httpBasic(clientId, clientSecret))
                    // dependency 추가, id, secret 을 가지고 basic auth 헤더를 만든 것
                    .param("username", username)
                    .param("password", password)
                    .param("grant_type", "password")
                )
            .andDo(print())
            .andExpect(status().isOk())
            .andExpect(jsonPath("access_token").exists())
        ;
    }

인증서버를 설정하지 않았기 때문에 테스트는 당연히 실패 !


인증 서버 설정을 해보자!

AuthServerConfig
    @Configuration
    @EnableAuthorizationServer
    public class AuthServerConfig extends AuthorizationServerConfigurerAdapter { ... }


메소드 오버라이딩
    @Autowired
    PasswordEncoder passwordEncoder;

    @Override
    public void configure(AuthorizationServerSecurityConfigurer security) throws Exception {
        security.passwordEncoder(passwordEncoder);
    }
    클라이언트의 시크릿을 확인 할 때 패스워드 인코더를 사용


메소드 오버라이딩
    @Override
    public void configure(ClientDetailsServiceConfigurer clients) throws Exception {
        clients.inMemory()
                .withClient("myApp")
                // 앱 Id
                .authorizedGrantTypes("password", "refresh_token")
                // 인증서버가 지원할 GrantType은 패스워드와 리프레쉬 토큰.
                // OAuth 토큰을 발급 받을 때 리프레쉬 토큰을 발급해 주는데
                // 이 토큰을 가지고 새로운 액세스 토큰을 발급받을 수 있다.
                .scopes("read", "write")
                // 임의로 권한의 scope을 지정하면 된다.
                .secret(this.passwordEncoder.encode("pass"))
                // 앱의 Secret
                .accessTokenValiditySeconds(10 * 60)
                // 액세스 토큰의 유효한 시간은 몇초인지, 10분
                .refreshTokenValiditySeconds(60 * 60);
                // 리프레쉬 토큰의 유효한 시간은 몇초인지, 1시간
    }
    인메모리로 만들었지만 가장 이상적인 것은 jdbc로 만들어 DB에서 관리하는게 좋다.
    우선은 인메모리로 만들어서 쓰자


메소드 오버라이딩
    @Autowired
    AuthenticationManager authenticationManager;
    // 다른 데서도 사용할 수 있도록 SecurityConfig에서 빈으로 만들어놨음.
    // 유저 인증 정보를 가지고 있다.

    @Autowired
    AccountService accountService;

    @Autowired
    TokenStore tokenStore;

    @Override
    public void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception {
        endpoints.authenticationManager(authenticationManager)
                .userDetailsService(accountService)
                .tokenStore(tokenStore);
    }


인증서버 구현 완료

토큰을 발급받을 수 있고, 토큰을 가지고 인증 해서
토큰을 가지고 리소스(이벤트)들에 접근할 때
어떻게 인증 토큰을 사용할 것인지는 리소스 서버에서 결정하는 것.
