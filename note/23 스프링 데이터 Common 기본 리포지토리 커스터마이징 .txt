23. 스프링 데이터 Common: 기본 리포지토리 커스터마이징 

'모든' 리포지토리에 공통적으로 추가하고 싶은 기능이 있거나 덮어쓰고 싶은 기본 기능이 있다면

1. JpaRepository를 상속 받는 인터페이스 정의
    ○ @NoRepositoryBean

2. 기본 구현체를 상속 받는 커스텀 구현체 만들기

3. @EnableJpaRepositories에 설정
    ○ repositoryBaseClass

------------------------------------------------------------------------------------------------

[상황] 어떤 엔티티가 persistent 상태에 들어있는지 아닌지를 확인하는 기능이 매 리포지토리마다 있으면 좋겠다.

@NoRepositoryBean
public interface MyRepository<T, ID extends Serializable> extends JpaRepository<T, ID> {
    boolean contains(T entity);
}

public class SimpleMyRepository<T, ID extends Serializable> extends SimpleJpaRepository<T, ID> implements MyRepository<T, ID> { 
    private EntityManager entityManager;

    public SimpleMyRepository(JpaEntityInformation<T, ?> entityInformation, EntityManager entityManager) {
         super(entityInformation, entityManager);
         this.entityManager = entityManager;
    }
    @Override
    public boolean contains(T entity) {
        return entityManager.contains(entity);
    }
}
 
@EnableJpaRepositories(repositoryBaseClass = SimpleMyRepository.class)

public interface PostRepository extends MyRepository<Post, Long> { }

------------------------------------------------------------------------------------------------

[실습]

    모든 리포지토리에 공통적으로 추가하고 싶은 기능이 있거나 덮어쓰고 싶은 기본 기능이 있다면
    모든 엔티티에 대한 리포지토리 커스터마이징
    (예전 강의는 Post 리포지토리 한정이었음 - 이 경우 PostCustomRepository 와 구현부를 만들어야 한다.)
    (매번 두 클래스를 생성할게 아니라 레파지토리들이 기본적으로 사용하는 기능이 있다면 아래 방식대로 하면 된다.)

    @NoRepositoryBean
    // 얘는 JpaRepository 를 상속받더라도 빈으로 만들어지면 안된다. 다른 구현체의 Base 로 사용할 것이다.
    // 중간에 만들어지는 레파지토리에는 꼭 붙어있어야 한다
    public interface MyRepository<T, ID> extends JpaRepository<T, ID>{
        boolean contains(T entity);
    }

    구현체를 만들자
    이 경우에는 클래스 명에 제한 없음(이전에는 Impl이 접미어로 붙었어야 했음)

    SimpleJpaRepository? 흔히 JpaRepository 를 상속받은 인터페이스를 만들 때 만들어지는 레파지토리.
    커스터마이징 리파지토리 구현체는 SimpelJpaRepository 를 상속받고 우리가 만든 레파지토리 인터페이스를 구현해야 한다.

    public class SimpleMyRepository<T, ID extends Serializable>
                        extends SimpleJpaRepository<T, ID>
                        implements MyRepository<T, ID> {

        private Entity entityManager; // 빈으로 주입받는게 아니라 생성자에서 전달받아 사용

        public SimpleMyRepository(...){
            super(..., ...); // SimpleJpaRepository 생성자에 전달해야 함.
            this.entityManager = ... ;
        }

        @override
        public boolean contains(...) {
            return entityManager.contains(entity);
        }
    }
    // 생성자를 만들어줘야 한다.
    // 우리가 만든 추상 메소드를 구현해줘야 함

    레파지토리들이 기본적으로 사용할 클래스가 무엇인지 알려줘야 한다.

    @SpringBootApplication
    @EnableJpaRepositories(repositoryBaseClass = SimpleMyRepository.class))
    public class Application {}

    이제는 이 기능을 사용할 레파지토리에서 상속받아서 사용하면 된다.

    public interface PostRepository extends MyRepository<Post, Long> {
    }

    (1) 새로운 기능을 만들때는 MyRepository 에서 abstract 를 써주고 구현체에서 구현하고
    (2) 기존의 레파지토리 기능을 재정의할 때에는 구현체에서 바로 상속받아서 사용하면 된다.
    (BaseRepository-SimpleMyRepository-가 SimpleJpaRepository를 상속받고 있기 때문에 기본적인 기능들이 있다)

테스트!

    @Test
    public void crud() {
        Post post = new Post();
        post.setTitle("hibernte"); // transient state
        assertThat(postRepository.contains(post)).isFalse();

        postRepository.save(post); // persist state

        assertThat(postRepository.contains(post)).isTrue();

        postRepository.delete(post);
        postRepository.flush();
    }


