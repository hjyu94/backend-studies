5.ORM: 패러다임 불일치

ORM은 애플리케이션의 클래스와 SQL 데이터베이스의 테이블 사이의 맵핑 정보를 기술한 메타데이터를 사용하여,
자바 애플리케이션의 객체를 SQL 데이터베이스의 테이블에 자동으로 (또 깨끗하게) 영속화 해주는 기술입니다.

객체를 릴레이션에 맵핑하려니 발생하는 문제들과 해결책
// 실제 그렇게 영속화하려니 발생하는 문제점들이 있다

객체 <--> 릴레이션(테이블)

[1] 밀도(Granularity) 문제
    객체
    - 다양한 크기의 객체를 만들 수 있음.
    - 커스텀한 타입 만들기 쉬움.

    릴레이션
    - 테이블
    - 기본 데이터 타입 (UDT는 비추)

ex
    public class Account {
        pirvate Long id;
        String address;
        List<Study> studies;
    }

    public class Address {
        private String zipcode;
        private String city;
        private String street;
    }

    Account.address 를 String 으로 할 수도 있고, Address 타입으로 할 수도 있다.
    객체에서는 얼마던지 원하는 데이터 타입으로 만들 수 있고, 객체의 크기를 자유롭게 조절할 수 있다.

    릴레이션에는 릴레이션 안에 들어가 있는 컬럼들의 데이터 타입(int, varchar) 밖에 없다.
    user-defined type을 만들 수도 있지만 잘 쓰이지 않는다.
    표준자체도 잘 정해져 있지 않고 데이터베이스 간에 서로 호환된다는 보장도 없기 때문.

    객체와 릴레이션 사이에는 이런 차이로 인해 문제가 생기지만
    ORM 은 이를 극복할 해결책을 줄 수 있다.


[2] 서브타입(Subtype) 문제
    객체
    - 상속 구조 만들기 쉬움.
    - 다형성.

    릴레이션
    - 테이블 상속이라는게 없음.
    - 상속 기능을 구현했다 하더라도 표준 기술이 아님.
    - 다형적인 관계를 표현할 방법이 없음.

ex
    객체를 만들때 어떠한 인터페이스를 만들고 이를 구현하는 구현체를 만들거나
    상속구조를 만들기가 쉽다.
    그러한 상속구조를 이용해서 다형성을 이용할수도 있다.

    public interface BillingAccount;
    public class BankAccount implements BillingAccount;
    public class CreditCard implements

    public class User {
        BillingAccount mainBillingAccount;
    }
    이 사용자가 사용하는 주요한 결제 수단이 무엇인지 나타내는데
    타입은 BillingAccount 이고,
    인터페이스 타입에 해당하는 객체는 BankAccount, CreditCard 둘 중 하나가 될 수 있다.

    이런 구조를 릴레이션에 매핑하려고 하면 문제가 생김.
    한 다른 테이블에 있는 주키를 외래키로 설정할 수 있는거지
    다른 두 테이블에 있는 주키를 외래키로 설정할 수는 없다
    (다른 두 테이블 간의 키가 겹칠 수도 있고)

    이런 문제에 대한 해결책을 ORM 이 제공해준다!


[3] 식별성(Identity) 문제
    객체
    - 레퍼런스 동일성 (==)
    - 인스턴스 동일성 (equals() 메소드)

    릴레이션
    - 주키 (primary key)

//
    어떠한 인스턴스가 같은지 확인할 때는
    1. reference 동일성
    2. 인스턴스의 동일성(equals()) (->권장하는 방법)
    두 가지가 있는데

    데이터베이스와 매핑이 될 때
    인스턴스의 동일성만 따지기에는 충분하지 않다.
    릴레이션에서 어떤 다른 두 레코드간의 동일성은 주 키가 핵심.
    테이블에 있는 주키가 같으냐 다르냐에 따라 두 레코드가 같은 레코드인지 다른 레코드인지 판단하게 된다.

    객체에는 주키같은 개념이 없어 불일치되는데 이를 ORM이 해결해준다!
//


[4] 관계(Association) 문제
    객체
    - 객체 레퍼런스로 관계 표현.
    - 근본적으로 ‘방향'이 존재 한다.
    - 다대다 관계를 가질 수 있음

    릴레이션
    - 외래키(foreign key)로 관계 표현.
    - ‘방향'이라는 의미가 없음. 그냥 Join으로 아무거나 묶을 수 있음.
    - 태생적으로 다대다 관계를 못만들고, 조인 테이블 또는 링크 테이블을 사용해서 두개의 1대다 관계로 풀어야 함.

//
    public class Study {
        private User owner;
    }
    // Study->User를 참조하는 방향이 있다.

    public class User {
        private List<Study> myStudy;
    }
    // User에서 Study를 가리킴. 여러 컬렉션을 이용해서 다대다 관계 표현.

    이러한 관계를 릴레이션에서는 외래키로 표현할 순 있어도 방향을 나타내기 어렵다.
//


[5] 데이터 네비게이션(Navigation)의 문제
    객체
    - 레퍼런스를 이용해서 다른 객체로 이동 가능.
    - 콜렉션을 순회할 수도 있음.

    릴레이션
    - 하지만 그런 방식은 릴레이션에서 데이터를 조회하는데 있어서 매우 비효율적이다.
    - 데이터베이스에 요청을 적게 할 수록 성능이 좋다. 따라서 Join을 쓴다.
    - 하지만, 너무 많이 한번에 가져오려고 해도 문제다.
    - 그렇다고 lazy loading을 하자니 그것도 문제다. (n+1 select)

//
    class Study {
        public void hello(){
            getOwner().getMyStudy().stream().forEach(s->s.getOwner());
        }
    }

    가장 복잡하고 성능에도 문제가 되고 해결책도 경우에 따라 다르기 때문에 해결하기 어려운 케이스

    객체에서 데이터 네비게이션이란
    레퍼런스를 타고 원하는 데이터를 원하는 방법으로 사용하면 되는데

    릴레이션에서는 이러한 기능이 없다.
    외래키로 참조를 한다고 하더라도 매번 원하는 데이터를 join 해서 가지고 온다면

    Study 데이터를 select로 가지고 와.
    Owner 에 대한 외래키값을 사용해서
    유저정보를 쿼리한다.
    유저정보를 통해서 유저정보가 매핑하고 있는 조인테이블을 이용해서
    스터디 테이블을 쿼리함.
    쿼리한 스터디 목록을 사용해서 각각의 오너 정보를 쿼리한다.
    벌써 sql 쿼리가 많이 발생하는데
    sql 이 여러번 발생할 수록 성능이 하락되버린다.

    sql은 커넥션을 만드는 것 자체가 비싼 활동이기 때문에 가급적 한 트랜잭션 내에서 사용하는 쿼리를 줄이는게 유리한데
    이를 위해서 join 을 통해 많은 데이터를 왕창 올려버리게 되는 경우라면.
    너무 많은 조인을 해서 데이터를 왕창 메모리에 올려놓는다고 하더라도
    그 많은 데이터를 해당 트랜잭션에서 쓸 것이냐 하는 문제가 있다.
    쓰지도 않을 데이터를 메모리에 올리는 것도 부하가 될 수 있음.

    스터디 목록을 읽어와서 스터디 목록을 조회하면서 Owner 의 정보를 읽어 와야 하는 상황인데.
    lazy loading 을 이용해서 스터디에 목록을 가지고 올 때 조인해서 오너의 정보를 같이 가지고 오지 않고
    딱 스터디의 목록만 가지고 온 다음, 실질적으로 스터디 목록을 화면에 표시할 때
    스터디의 오너를 그때 그때 select 한다고 해보자.

    스터디의 목록을 가지고 올 때 쿼리 1번,
    스터디 목록을 순회하면서 생기는 쿼리들 n번.
    쿼리가 1+n 개 발생했기 때문에 성능에 좋을 수가 없다.
//