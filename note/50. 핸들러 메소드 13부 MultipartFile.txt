50. 핸들러 메소드 13부: MultipartFile

MultipartFile
    ● 파일 업로드시 사용하는 메소드 아규먼트
    ● MultipartResolver 빈이 설정 되어 있어야 사용할 수 있다. (스프링 부트 자동 설정이 해 줌)
    ● POST multipart/form-data 요청에 들어있는 파일을 참조할 수 있다.
    ● List<MultipartFile> 아큐먼트로 여러 파일을 참조할 수도 있다.

파일 업로드 폼
    <form method="POST" enctype="multipart/form-data" action="#" th:action="@{/file}">
        File: <input type="file" name="fileXX"/>
        <input type="submit" value="Upload"/>
    </form>

파일 업로드 처리 핸들러
    @PostMapping("/file")
    public String fileUpload(
            @RequestParam MultipartFile file,
            , RedirectAttributes attributes) {
        String message = file.getOriginalFilename() + " is uploaded.";
        System.out.println(message);
        attributes.addFlashAttribute("message", message);
        return "redirect:/events/list";
    }

메시지 출력
    <div th:if="${message}">
        <h2 th:text="${message}"/>
    </div>

파일 업로드 관련 스프링 부트 설정
    ● MultipartAutoConfiguration
    ● MultipartProperties

참고
    ● https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#mvc-mul tipart-forms
    ● https://spring.io/guides/gs/uploading-files/


[실습]

MultipartFile을 메소드 아규먼트로 사용하려면
MultipartResolver가 DispatcherServlet에 설정되어 있어야 한다

* DispatcherServlet?
    초기화 과정 중에 디스팻쳐 서블릿은 자신이 사용할 여러가지 빈들을 application context에서 가져와서 설정.
    없으면 아예 사용하지 않거나 기본전략을 사용한다.

    [DispatcherServlet.java]

    protected void initStrategies(ApplicationContext context) {
        this.initMultipartResolver(context);
        this.initLocaleResolver(context);
        ...
    }

    private void initMultipartResolver(ApplicationContext context) {
        try {
            this.multipartResolver = (MultipartResolver)context.getBean("multipartResolver", MultipartResolver.class);
            if (this.logger.isTraceEnabled()) {
                this.logger.trace("Detected " + this.multipartResolver);
            } else if (this.logger.isDebugEnabled()) {
                this.logger.debug("Detected " + this.multipartResolver.getClass().getSimpleName());
            }
        } catch (NoSuchBeanDefinitionException var3) {
            this.multipartResolver = null; // ***
            if (this.logger.isTraceEnabled()) {
                this.logger.trace("No MultipartResolver 'multipartResolver' declared");
            }
        }

    }

기본적으로는 멀티파트 리졸버가 없지만 스프링 부트를 사용하는 경우에는
아무런 설정을 따로 하지 않아도 스프링 부트 자동 설정 파일로 인해 파일업로드 처리를 할 수 있다.

* MultipartAutoConfiguration(자동설정파일)
    spring.factories 검색 [multipart]

    [MultipartAutoConfiguration.java]
    @EnableConfigurationProperties({MultipartProperties.class})
    public class MultipartAutoConfiguration {
        ...

        @Bean(
            name = {"multipartResolver"}
        )
        @ConditionalOnMissingBean({MultipartResolver.class})
        public StandardServletMultipartResolver multipartResolver() {
            ...
        }
    }

    이 안에서 StandardServletMultipartResolver 를 빈으로 등록한다.
    이 설정에서 사용하는 프로퍼티는 MultipartProperties.java에 정의되어있다.

    커스터마이징 해서 사용할때는 application.properties 에서 값을 주면 된다.
    spring.servlet.multipart prefix를 사용한다.


우리는 스프링부트를 사용하고 있기 때문에 기본적인 멀티파트 리졸버가 존재한다.

[resources/templates/files/index.html]
    <!DOCTYPE html>
    <html lang="en" xmlns:th="http://www.thymeleaf.org">
    <head>
        <meta charset="UTF-8"/>
        <title>File Upload</title>
    </head>
    <body>
        <form method="POST" enctype="multipart/form-data" action="#" th:action="@{/file}">
            File: <input type="file" name="fileXX"/>
            <input type="submit" value="Upload"/>
        </form>
    </body>
    </html>

submit 버튼을 클릭하는 경우 요청에 file을 담아서 /file Post 요청을 보낸다.
요청에 들어있는 파일은 MultipartFile 타입의 아규먼트로 받을 수 있다.

[SampleController.java]
    @Controller
    public class SampleController {
        @GetMapping("/file")
        public String fileUploadForm(Model model)
        // 세션에 message가 담겨서 온다. 이 메세지는 model에 자동으로 담긴다.
        {
            return "files/index";
        }

        @PostMapping("/file")
        public String fileUpload(
                @RequestParam("fileXX") MultipartFile file // fileXX 이라는 file 을 아규먼트로 받는다
                , RedirectAttributes attributes) // file에 관련된 메세지를 작성해서 리다이렉트하는 곳에서 사용할 수 있도록 하자
        {
            // file save ...

            String message = file.getOriginalFilename() + " is uploaded";
            attributes.addFlashAttribute("message", message);
            // 세션에 message 데이터를 넣어둔 후 리다이렉트 이후 세션에서 사라진다.

            return "redirect:/file";
            // [GET] /file 요청으로 리다이렉트한다.
            // 리다이렉트된 메세지는 모델에 자동으로 담긴다.
        }
    }

리다이렉트 후 index.html에서 메세지를 보여줄 수 있도록 하자.

[resources/templates/files/index.html]
    ...
    <body>
        <div th:if="${message}">
            <h2 th:text="${message}"/>
        </div>
        ...
    </body>


* 실행
    http://localhost:8080/file

* 테스트 코드
    @RunWith(SpringRunner.class)
    @SpringBootTest
    // @SpringBootApplication 기준으로 모든 빈을 등록해서
    // 애플리케이션 전반에 관련된 테스트를 작성하고자 하는 경우 사용한다
    // 단 이경우는 모든 빈을 자동으로 등록 해주지만 MockMvc를 주입받아 사용할 수 없다.
    @AutoConfigureMockMvc // MockMvc를 주입받아 사용하기 위해 추가!
    public class FileControllerTest {

        @Autowired
        MockMvc mockMvc;

        @Test
        public void fileUploadTest() throws Exception {
            MockMultipartFile file = new MockMultipartFile(
                    "file", "test.txt"
                    , "text/plain"
                    , "hello file".getBytes());
            // 스프링 mvc 에서 제공하는 클래스. 가짜 파일을 만들 수 있다.

            this.mockMvc.perform(multipart("/file")
                                // multipart 자체는 post 요청이고 enctype이 form-data 임
                            .file(file))
                    .andDo(print())
                    .andExpect(status().is3xxRedirection())
            ;
        }
    }